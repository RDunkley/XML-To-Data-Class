/********************************************************************************************************************************
 * Copyright 2014 Richard Dunkley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text;
using XMLToDataClass.Data;

namespace XMLToDataClass
{
	/// <summary>
	///   Provides the methods to generate data classes from an <see cref="XMLInfo"/> object.
	/// </summary>
	public static class DataClassCodeGen
	{
		#region Fields

		/// <summary>
		///   Name of the CDATA property in the data class.
		/// </summary>
		public const string CDATAPropertyName = "Data";

		/// <summary>
		///   Name of the CDATA valid property in the data class.
		/// </summary>
		public const string CDATAValidPropertyName = "IsDataValid";

		/// <summary>
		///   Name of the Text property in the data class.
		/// </summary>
		public const string TextPropertyName = "Text";

		/// <summary>
		///   Name of the Text valid property in the data class.
		/// </summary>
		public const string TextValidPropertyName = "IsTextValid";

		#endregion Fields

		#region Methods

		/// <summary>
		///   Generates the class code for the specified XML node.
		/// </summary>
		/// <param name="name">XML node name of the XML node which the class will be generated from.</param>
		/// <param name="lookup"><see cref="XMLInfo"/> containing lookup information on the XML file.</param>
		/// <param name="codeOutputFolder">Full path to the folder to generate the code in.</param>
		/// <exception cref="ArgumentNullException">One of the input parameters is a null reference.</exception>
		/// <exception cref="ArgumentException"><i>name</i> is an empty string or <i>codeOutputFolder</i> is not valid.</exception>
		public static void GenerateDataClass(ElementInfo element, string codeOutputFolder)
		{
			if (element == null)
				throw new ArgumentNullException("element");

			if (codeOutputFolder == null)
				throw new ArgumentNullException("codeOutputFolder");
			try
			{
				codeOutputFolder = Path.GetFullPath(codeOutputFolder);
			}
			catch (Exception e)
			{
				throw new ArgumentException(string.Format("The directory specified in codeOutputFolder ({0}) is not valid. See inner exception.", codeOutputFolder), e);
			}

			if (!Directory.Exists(codeOutputFolder))
				throw new ArgumentException(string.Format("The directory specified in codeOutputFolder ({0}) does not exist.", codeOutputFolder));

			string fileName = string.Format("{0}.cs", element.ClassName);
			using (StreamWriter wr = new StreamWriter(Path.Combine(codeOutputFolder, fileName)))
			{
				string ws = CodeGenHelper.CreateWhiteSpace(1);
				string summary;
				wr.Write(CodeGenHelper.CreateFileHeader(fileName, string.Format("This file was auto-generated by XMLToDataClass ({0}) based on XML element {1} provided.", Assembly.GetExecutingAssembly().GetName().Version, element.Name)));
				wr.WriteLine("using System;");
				wr.WriteLine();
				wr.WriteLine("namespace XMLToDataClass");
				wr.WriteLine("{");
				wr.Write(CodeGenHelper.CreateDocumentation(string.Format("In memory representation of the XML element \"{0}\".", element.Name), null, null, null, null, null, null, 1));
				wr.WriteLine(string.Format("{0}public class {1}", ws, element.ClassName));
				wr.WriteLine(string.Format("{0}{{", ws));

				ws = CodeGenHelper.CreateWhiteSpace(2);

				// Add text property.
				if (element.HasText)
				{
					string typeString = DataTypeUtility.GetDataTypeString(element.TextDataType);
					summary = string.Format("Gets or sets the value of the child {0} element.", TextPropertyName);
					wr.Write(CodeGenHelper.CreateDocumentation(summary, null, null, null, null, null, null, 2));
					wr.WriteLine(string.Format("{0}public {1} {2} {{ get; private set; }}", ws, typeString, TextPropertyName));
					wr.WriteLine();

					if (element.TextIsOptional)
					{
						summary = string.Format("Gets whether the value of the child {0} element is valid.", TextPropertyName);
						wr.Write(CodeGenHelper.CreateDocumentation(summary, null, null, null, null, null, null, 2));
						wr.WriteLine(string.Format("{0}public bool {1} {{ get; private set; }}", ws, TextValidPropertyName));
						wr.WriteLine();
					}
				}

				// Add CDATA property.
				if (element.HasCDATA)
				{
					summary = string.Format("Gets or sets the value of the child {0} element.", CDATAPropertyName);
					wr.Write(CodeGenHelper.CreateDocumentation(summary, null, null, null, null, null, null, 2));
					wr.WriteLine(string.Format("{0}public string {1} {{ get; private set; }}", ws, CDATAPropertyName));
					wr.WriteLine();

					if (element.CDATAIsOptional)
					{
						summary = string.Format("Gets whether the value of the child {0} element is valid.", CDATAPropertyName);
						wr.Write(CodeGenHelper.CreateDocumentation(summary, null, null, null, null, null, null, 2));
						wr.WriteLine(string.Format("{0}public bool {1} {{ get; private set; }}", ws, CDATAValidPropertyName));
						wr.WriteLine();
					}
				}

				// Add properties to represent the attributes.
				for (int i = 0; i < element.Attributes.Length; i++)
				{
					string typeString = DataTypeUtility.GetDataTypeString(element.Attributes[i].AttributeType);
					summary = string.Format("Gets or sets the \"{0}\" XML attribute for the \"{1}\" element.", element.Attributes[i].Name, element.Name);
					wr.Write(CodeGenHelper.CreateDocumentation(summary, null, null, null, null, null, null, 2));
					wr.WriteLine(string.Format("{0}public {1} {2} {{ get; private set; }}", ws, typeString, element.Attributes[i].PropertyName));
					wr.WriteLine();

					if (element.Attributes[i].IsOptional || element.Attributes[i].CanBeEmpty)
					{
						summary = string.Format("Gets whether the \"{0}\" XML attribute has valid data.", element.Attributes[i].Name);
						wr.Write(CodeGenHelper.CreateDocumentation(summary, null, null, null, null, null, null, 2));
						wr.WriteLine(string.Format("{0}public bool {1} {{ get; private set; }}", ws, element.Attributes[i].PropertyValidName));
						wr.WriteLine();
					}
				}

				// Add properties to represent the child nodes.
				foreach(ElementInfo child in element.Children)
				{
					summary = "Gets or sets the child XML elements.";
					wr.Write(CodeGenHelper.CreateDocumentation(summary, null, null, null, null, null, null, 2));
					wr.WriteLine(string.Format("{0}public {1}[] {2} {{get; private set; }}", ws, child.ClassName, child.ChildArrayNameProperty));
					wr.WriteLine();
				}

				// Create the data class constructor.
				wr.WriteLine(GenerateDataClassConstructor(element));

				wr.WriteLine(string.Format("{0}}}", CodeGenHelper.CreateWhiteSpace(1)));
				wr.WriteLine("}");
			}
		}

		/// <summary>
		///   Generates the code for the data class's constructor.
		/// </summary>
		/// <param name="info"><see cref="ElementInfo"/> object containing information on the element to create the data class constructor for.</param>
		/// <returns>String containing all the code for the method.</returns>
		/// <remarks>Does not put a blank line after the method.</remarks>
		private static string GenerateDataClassConstructor(ElementInfo info)
		{
			string summary = string.Format("Instantiates a new {0} object using the provided information.", info.ClassName);

			int parameterNum = info.Attributes.Length + info.Children.Length;
			if(info.HasText)
				parameterNum++;
			if(info.HasCDATA)
				parameterNum++;

			// Add parameters for each property.
			string[] parameters = new string[parameterNum];
			string[] descriptions = new string[parameterNum];
			int index = 0;
			string textLower = CodeGenHelper.GetCamelCase(TextPropertyName);
			string dataLower = CodeGenHelper.GetCamelCase(CDATAPropertyName);
			if(info.HasText)
			{
				parameters[index] = textLower;
				descriptions[index] = "Child Text element value.";
				if(info.TextIsOptional)
					descriptions[index] = descriptions[index] + " Can be null.";
				index++;
			}

			if (info.HasCDATA)
			{
				parameters[index] = dataLower;
				descriptions[index] = "Child CDATA element value.";
				if (info.CDATAIsOptional)
					descriptions[index] = descriptions[index] + " Can be null.";
				index++;
			}

			for (int i = 0; i < info.Attributes.Length; i++)
			{
				parameters[index] = CodeGenHelper.GetCamelCase(info.Attributes[i].PropertyName);
				descriptions[index] = GetDataClassConstructorParameterDescription(info.Attributes[i]);
				index++;
			}

			// Add parameters for each child collection.
			for (int i = 0; i < info.Children.Length; i++)
			{
				parameters[index] = info.Children[i].ChildArrayNameVariable;
				descriptions[index] = string.Format("Array of {0} elements which are child elements of this node.", info.Children[i].Name);
				index++;
			}

			StringBuilder sb = new StringBuilder();
			List<string> nullExceptions = new List<string>();
			List<string> emptyExceptions = new List<string>();

			sb.AppendLine(GenerateDataClassConstructorSignature(info));

			sb.AppendLine(string.Format("{0}{{", CodeGenHelper.CreateWhiteSpace(2)));

			// Validate the text value.
			string ws3 = CodeGenHelper.CreateWhiteSpace(3);
			string ws4 = CodeGenHelper.CreateWhiteSpace(4);
			if (info.HasText && !info.TextIsOptional)
			{
				nullExceptions.Add(textLower);
				sb.AppendLine(string.Format("{0}if({1} == null)", ws3, textLower));
				sb.AppendLine(string.Format("{0}throw new ArgumentNullException(\"{1}\");", ws4, textLower));
				sb.AppendLine();
			}

			// Validate the CDATA value.
			if (info.HasCDATA && !info.CDATAIsOptional)
			{
				nullExceptions.Add(dataLower);
				sb.AppendLine(string.Format("{0}if({1} == null)", ws3, dataLower));
				sb.AppendLine(string.Format("{0}throw new ArgumentNullException(\"{1}\");", ws4, dataLower));
				sb.AppendLine();

				emptyExceptions.Add(dataLower);
				sb.AppendLine(string.Format("{0}if({1}.Length == 0)", ws3, dataLower));
				sb.AppendLine(string.Format("{0}throw new ArgumentException(\"{1} is an empty string\");", ws4, dataLower));
				sb.AppendLine();
			}

			// Validate the attributes.
			for (int i = 0; i < info.Attributes.Length; i++)
			{
				if (info.Attributes[i].AttributeType == DataType.String)
				{
					string camel = CodeGenHelper.GetCamelCase(info.Attributes[i].PropertyName);
					if (info.Attributes[i].IsOptional)
					{
						if (!info.Attributes[i].CanBeEmpty)
						{
							emptyExceptions.Add(camel);
							sb.AppendLine(string.Format("{0}if({1} != null && {1}.Length == 0)", ws3, camel));
							sb.AppendLine(string.Format("{0}throw new ArgumentException(\"{1} is an empty string\");", ws4, camel));
							sb.AppendLine();
						}
					}
					else
					{
						// If the attribute is not optional check for null.
						nullExceptions.Add(camel);
						sb.AppendLine(string.Format("{0}if({1} == null)", ws3, camel));
						sb.AppendLine(string.Format("{0}throw new ArgumentNullException(\"{1}\");", ws4, camel));
						sb.AppendLine();

						// If the attribute can't be empty then check for it.
						if (!info.Attributes[i].CanBeEmpty)
						{
							emptyExceptions.Add(camel);
							sb.AppendLine(string.Format("{0}if({1}.Length == 0)", ws3, camel));
							sb.AppendLine(string.Format("{0}throw new ArgumentException(\"{1} is an empty string\");", ws4, camel));
							sb.AppendLine();
						}
					}
				}
			}

			// Validate the arrays.
			for (int i = 0; i < info.Children.Length; i++)
			{
				string camel = info.Children[i].ChildArrayNameVariable;
				nullExceptions.Add(camel);
				sb.AppendLine(string.Format("{0}if({1} == null)", ws3, camel));
				sb.AppendLine(string.Format("{0}throw new ArgumentNullException(\"{1}\");", ws4, camel));
				sb.AppendLine();
			}

			// Assign the text.
			if (info.HasText)
			{
				if (info.TextIsOptional)
				{
					sb.AppendLine(string.Format("{0}if({1}.HasValue)", ws3, textLower));
					sb.AppendLine(string.Format("{0}{{", ws3));
					sb.AppendLine(string.Format("{0}{1} = true;", ws4, TextValidPropertyName));
					sb.AppendLine(string.Format("{0}{1} = {2}.Value;", ws4, TextPropertyName, textLower));
					sb.AppendLine(string.Format("{0}}}", ws3));
					sb.AppendLine(string.Format("{0}else", ws3));
					sb.AppendLine(string.Format("{0}{{", ws3));
					sb.AppendLine(string.Format("{0}{1} = false;", ws4, TextValidPropertyName));
					sb.AppendLine(string.Format("{0}}}", ws3));
				}
				else
				{
					sb.AppendLine(string.Format("{0}{1} = {2};", ws3, TextPropertyName, textLower));
				}
			}

			// Assign the CDATA.
			if (info.HasCDATA)
			{
				if (info.CDATAIsOptional)
				{
					sb.AppendLine(string.Format("{0}if({1} == null)", ws3, dataLower));
					sb.AppendLine(string.Format("{0}{{", ws3));
					sb.AppendLine(string.Format("{0}{1} = false;", ws4, CDATAValidPropertyName));
					sb.AppendLine(string.Format("{0}{1} = null;", ws4, CDATAPropertyName));
					sb.AppendLine(string.Format("{0}}}", ws3));
					sb.AppendLine(string.Format("{0}else", ws3));
					sb.AppendLine(string.Format("{0}{{", ws3));
					sb.AppendLine(string.Format("{0}{1} = true;", ws4, CDATAValidPropertyName));
					sb.AppendLine(string.Format("{0}{1} = {2};", ws4, CDATAPropertyName, dataLower));
					sb.AppendLine(string.Format("{0}}}", ws3));
				}
				else
				{
					sb.AppendLine(string.Format("{0}{1} = {2};", ws3, CDATAPropertyName, dataLower));
				}
			}

			// Assign the properties.
			for (int i = 0; i < info.Attributes.Length; i++)
			{
				string camel = CodeGenHelper.GetCamelCase(info.Attributes[i].PropertyName);
				if (info.Attributes[i].AttributeType == DataType.String)
				{
					if (info.Attributes[i].IsOptional)
					{
						if (info.Attributes[i].CanBeEmpty)
						{
							sb.AppendLine(string.Format("{0}if({1} == null || {1}.Length == 0)", ws3, camel));
							sb.AppendLine(string.Format("{0}{{", ws3));
							sb.AppendLine(string.Format("{0}{1} = false;", ws4, info.Attributes[i].PropertyValidName));
							sb.AppendLine(string.Format("{0}{1} = null;", ws4, info.Attributes[i].PropertyName));
							sb.AppendLine(string.Format("{0}}}", ws3));
							sb.AppendLine(string.Format("{0}else", ws3));
							sb.AppendLine(string.Format("{0}{{", ws3));
							sb.AppendLine(string.Format("{0}{1} = true;", ws4, info.Attributes[i].PropertyValidName));
							sb.AppendLine(string.Format("{0}{1} = {2};", ws4, info.Attributes[i].PropertyName, camel));
							sb.AppendLine(string.Format("{0}}}", ws3));
						}
						else
						{
							sb.AppendLine(string.Format("{0}if({1} == null)", ws3, camel));
							sb.AppendLine(string.Format("{0}{{", ws3));
							sb.AppendLine(string.Format("{0}{1} = false;", ws4, info.Attributes[i].PropertyValidName));
							sb.AppendLine(string.Format("{0}{1} = null;", ws4, info.Attributes[i].PropertyName));
							sb.AppendLine(string.Format("{0}}}", ws3));
							sb.AppendLine(string.Format("{0}else", ws3));
							sb.AppendLine(string.Format("{0}{{", ws3));
							sb.AppendLine(string.Format("{0}{1} = true;", ws4, info.Attributes[i].PropertyValidName));
							sb.AppendLine(string.Format("{0}{1} = {2};", ws4, info.Attributes[i].PropertyName, camel));
							sb.AppendLine(string.Format("{0}}}", ws3));
						}
					}
					else
					{
						if (info.Attributes[i].CanBeEmpty)
						{
							sb.AppendLine(string.Format("{0}if({1}.Length == 0)", ws3, camel));
							sb.AppendLine(string.Format("{0}{{", ws3));
							sb.AppendLine(string.Format("{0}{1} = false;", ws4, info.Attributes[i].PropertyValidName));
							sb.AppendLine(string.Format("{0}{1} = null;", ws4, info.Attributes[i].PropertyName));
							sb.AppendLine(string.Format("{0}}}", ws3));
							sb.AppendLine(string.Format("{0}else", ws3));
							sb.AppendLine(string.Format("{0}{{", ws3));
							sb.AppendLine(string.Format("{0}{1} = true;", ws4, info.Attributes[i].PropertyValidName));
							sb.AppendLine(string.Format("{0}{1} = {2};", ws4, info.Attributes[i].PropertyName, camel));
							sb.AppendLine(string.Format("{0}}}", ws3));
						}
						else
						{
							sb.AppendLine(string.Format("{0}{1} = {2};", ws3, info.Attributes[i].PropertyName, camel));
						}
					}
				}
				else
				{
					if (info.Attributes[i].IsOptional || info.Attributes[i].CanBeEmpty)
					{
						sb.AppendLine(string.Format("{0}if({1}.HasValue)", ws3, camel));
						sb.AppendLine(string.Format("{0}{{", ws3));
						sb.AppendLine(string.Format("{0}{1} = true;", ws4, info.Attributes[i].PropertyValidName));
						sb.AppendLine(string.Format("{0}{1} = {2}.Value;", ws4, info.Attributes[i].PropertyName, camel));
						sb.AppendLine(string.Format("{0}}}", ws3));
						sb.AppendLine(string.Format("{0}else", ws3));
						sb.AppendLine(string.Format("{0}{{", ws3));
						sb.AppendLine(string.Format("{0}{1} = false;", ws4, info.Attributes[i].PropertyValidName));
						sb.AppendLine(string.Format("{0}}}", ws3));
					}
					else
					{
						sb.AppendLine(string.Format("{0}{1} = {2};", ws3, info.Attributes[i].PropertyName, camel));
					}
				}
			}

			// Assign the arrays.
			for (int i = 0; i < info.Children.Length; i++)
				sb.AppendLine(string.Format("{0}{1} = {2};", ws3, info.Children[i].ChildArrayNameProperty, info.Children[i].ChildArrayNameVariable));

			sb.AppendLine(string.Format("{0}}}", CodeGenHelper.CreateWhiteSpace(2)));

			string code = sb.ToString();

			// Add the exceptions.
			List<string> exceptions = new List<string>(2);
			List<string> exceptionDescriptions = new List<string>(2);
			if (nullExceptions.Count > 0)
			{
				exceptions.Add("ArgumentNullException");
				exceptionDescriptions.Add(CodeGenHelper.CreateArgumentNullExceptionString(nullExceptions.ToArray()));
			}

			// Add the exceptions.
			if (emptyExceptions.Count > 0)
			{
				exceptions.Add("ArgumentException");
				exceptionDescriptions.Add(CodeGenHelper.CreateArgumentEmptyExceptionString(emptyExceptions.ToArray()));
			}

			string documentation = CodeGenHelper.CreateDocumentation(summary, parameters, descriptions, null, null, exceptions.ToArray(), exceptionDescriptions.ToArray(), 2);

			return documentation + code;
		}

		/// <summary>
		///   Generates the signature code line for the data class's constructor.
		/// </summary>
		/// <param name="info"><see cref="ElementInfo"/> object containing information on the element to create the data class constructor for.</param>
		/// <returns>String containing the signature.</returns>
		/// <remarks>Does not put a blank line after the method.</remarks>
		private static string GenerateDataClassConstructorSignature(ElementInfo info)
		{
			// Create the signature.
			StringBuilder sb = new StringBuilder();
			sb.Append(string.Format("{0}public {1}(", CodeGenHelper.CreateWhiteSpace(2), info.ClassName));

			// Add parameter for text.
			if (info.HasText)
			{
				sb.Append(DataTypeUtility.GetDataTypeString(info.TextDataType));
				if (DataTypeUtility.IsNullableType(info.TextDataType))
				{
					if (info.TextIsOptional)
						sb.Append("?");
				}
				sb.Append(string.Format(" {0}", CodeGenHelper.GetCamelCase(TextPropertyName)));

				if (info.Attributes.Length > 0 || info.HasCDATA || info.Children.Length > 0)
					sb.Append(", ");
			}

			// Add parameter for CDATA.
			if(info.HasCDATA)
			{
				sb.Append(string.Format("string {0}", CodeGenHelper.GetCamelCase(CDATAPropertyName)));
				if(info.Attributes.Length > 0 || info.Children.Length > 0)
					sb.Append(", ");
			}

			// Add parameters for each property.
			for (int i = 0; i < info.Attributes.Length; i++)
			{
				sb.Append(DataTypeUtility.GetDataTypeString(info.Attributes[i].AttributeType));
				if (DataTypeUtility.IsNullableType(info.Attributes[i].AttributeType))
				{
					if (info.Attributes[i].IsOptional || info.Attributes[i].CanBeEmpty)
						sb.Append("?");
				}
				sb.Append(" ");
				sb.Append(CodeGenHelper.GetCamelCase(info.Attributes[i].PropertyName));

				if (i != info.Attributes.Length - 1 || info.Children.Length > 0)
					sb.Append(", ");
			}

			// Add parameters for the child arrays.
			for (int i = 0; i < info.Children.Length; i++)
			{
				sb.Append(string.Format("{0}[] {1}", info.Children[i].ClassName, info.Children[i].ChildArrayNameVariable));

				if (i != info.Children.Length - 1)
					sb.Append(", ");
			}

			sb.Append(")");
			return sb.ToString();
		}

		/// <summary>
		///   Generates the parameter string for the attribute in its data class constructor method documentation.
		/// </summary>
		/// <param name="attrib"><see cref="AttributeInfo"/> to generate the parameter string for.</param>
		/// <returns>String containing the parameter string.</returns>
		/// <remarks>The return string does not contain any end-of-line characters.</remarks>
		private static string GetDataClassConstructorParameterDescription(AttributeInfo attrib)
		{
			switch (attrib.AttributeType)
			{
				case DataType.Boolean:
					return string.Format("\'{0}\' boolean attribute contained in the XML element.", attrib.Name);
				case DataType.DateTime:
					return string.Format("\'{0}\' date/time attribute contained in the XML element.", attrib.Name);
				case DataType.Double:
					return string.Format("\'{0}\' floating point decimal attribute contained in the XML element.", attrib.Name);
				case DataType.Int16:
					return string.Format("\'{0}\' 16-bit signed integer attribute contained in the XML element.", attrib.Name);
				case DataType.Int32:
					return string.Format("\'{0}\' 32-bit signed integer attribute contained in the XML element.", attrib.Name);
				case DataType.Int64:
					return string.Format("\'{0}\' 64-bit signed integer attribute contained in the XML element.", attrib.Name);
				case DataType.Int8:
					return string.Format("\'{0}\' 8-bit signed integer attribute contained in the XML element.", attrib.Name);
				case DataType.UInt16:
					return string.Format("\'{0}\' 16-bit unsigned integer attribute contained in the XML element.", attrib.Name);
				case DataType.UInt32:
					return string.Format("\'{0}\' 32-bit unsigned integer attribute contained in the XML element.", attrib.Name);
				case DataType.UInt64:
					return string.Format("\'{0}\' 64-bit unsigned integer attribute contained in the XML element.", attrib.Name);
				case DataType.UInt8:
					return string.Format("\'{0}\' 8-bit unsigned integer attribute contained in the XML element.", attrib.Name);
			}

			// Setup the string descriptions.
			if (attrib.IsOptional)
			{
				if (attrib.CanBeEmpty)
					return string.Format("\'{0}\' attribute contained in the XML element. Can be null or empty.", attrib.Name);
				else
					return string.Format("\'{0}\' attribute contained in the XML element. Can be null.", attrib.Name);
			}
			else
			{
				if (attrib.CanBeEmpty)
					return string.Format("\'{0}\' attribute contained in the XML element. Can be empty.", attrib.Name);
				else
					return string.Format("\'{0}\' attribute contained in the XML element.", attrib.Name);
			}
		}

		#endregion Methods
	}
}
